{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to XTLS_CRUD's documentation! Installation Install from PyPI pip install xtls_crud Install from source (build using poetry) git clone cd xtls_crud poetry build pip install dist/xtls_crud-<version>-py3-none-any.whl Install from GitHub pip install git+hhttps://github.com/amiwrprez/xtls_crud.git Usage You can use this package as library or you can run local web server with to use API for CRUD operations. See examples below. Web You can run local web server with to use API for CRUD operations. Run web server xtls_crud web serve Run web server with custom parameters xtls_crud web serve --host=0.0.0.0 --port=8080 Swagger UI To see API docs, go to: /docs ReDoc To see API docs, go to: /redoc Use as library You can use this package as library. See examples below. Examples See examples for examples.","title":"Introduction"},{"location":"#welcome-to-xtls_cruds-documentation","text":"","title":"Welcome to XTLS_CRUD's documentation!"},{"location":"#installation","text":"","title":"Installation"},{"location":"#install-from-pypi","text":"pip install xtls_crud","title":"Install from PyPI"},{"location":"#install-from-source-build-using-poetry","text":"git clone cd xtls_crud poetry build pip install dist/xtls_crud-<version>-py3-none-any.whl","title":"Install from source (build using poetry)"},{"location":"#install-from-github","text":"pip install git+hhttps://github.com/amiwrprez/xtls_crud.git","title":"Install from GitHub"},{"location":"#usage","text":"You can use this package as library or you can run local web server with to use API for CRUD operations. See examples below.","title":"Usage"},{"location":"#web","text":"You can run local web server with to use API for CRUD operations.","title":"Web"},{"location":"#run-web-server","text":"xtls_crud web serve","title":"Run web server"},{"location":"#run-web-server-with-custom-parameters","text":"xtls_crud web serve --host=0.0.0.0 --port=8080","title":"Run web server with custom parameters"},{"location":"#swagger-ui","text":"To see API docs, go to: /docs","title":"Swagger UI"},{"location":"#redoc","text":"To see API docs, go to: /redoc","title":"ReDoc"},{"location":"#use-as-library","text":"You can use this package as library. See examples below.","title":"Use as library"},{"location":"#examples","text":"See examples for examples.","title":"Examples"},{"location":"examples/","text":"Create new record from uuid import uuid4 from xtls_crud.utils.builders.inbounds_builder import EasyInboundBuilder from xtls_crud.database import crud async def main(): builder = EasyInboundBuilder().with_user_id(1).with_up(\"1gb\").with_down(\"1gb\").with_total( 0).with_remark(\"TEST\").with_enable(True).with_expiry_time( \"1D\").with_listen(\" \").with_port(1234).with_protocol(\"vmess\").with_uuid(uuid4()).with_network( \"ws\").with_security(\"tls\").with_server_name(\"v2ray.my-site.com\").with_ws_path( \"/test\").with_tag(\"inbound-49428\").with_sniffing(True).build() _ = await crud.inbounds.create(obj_in=builder) print(_) return _ if __name__ == '__main__': import asyncio asyncio.run(main()) Get all records Get all records from table. from uuid import uuid4 from xtls_crud.database import crud async def main(): _ = await crud.inbounds.get_multi() print(_) return _ if __name__ == '__main__': import asyncio asyncio.run(main())","title":"Examples"},{"location":"examples/#create-new-record","text":"from uuid import uuid4 from xtls_crud.utils.builders.inbounds_builder import EasyInboundBuilder from xtls_crud.database import crud async def main(): builder = EasyInboundBuilder().with_user_id(1).with_up(\"1gb\").with_down(\"1gb\").with_total( 0).with_remark(\"TEST\").with_enable(True).with_expiry_time( \"1D\").with_listen(\" \").with_port(1234).with_protocol(\"vmess\").with_uuid(uuid4()).with_network( \"ws\").with_security(\"tls\").with_server_name(\"v2ray.my-site.com\").with_ws_path( \"/test\").with_tag(\"inbound-49428\").with_sniffing(True).build() _ = await crud.inbounds.create(obj_in=builder) print(_) return _ if __name__ == '__main__': import asyncio asyncio.run(main())","title":"Create new record"},{"location":"examples/#get-all-records","text":"Get all records from table. from uuid import uuid4 from xtls_crud.database import crud async def main(): _ = await crud.inbounds.get_multi() print(_) return _ if __name__ == '__main__': import asyncio asyncio.run(main())","title":"Get all records"},{"location":"reference/SUMMARY/","text":"commands main web main constants byte_size time_info core settings database crud base crud_inbounds db base base_class session models inbounds schemas inbounds models inbounds easy_inbounds_builder inbounds settings sniffing stream_settings utils builders inbounds_builder web","title":"SUMMARY"},{"location":"reference/commands/","text":"","title":"commands"},{"location":"reference/commands/main/","text":"","title":"main"},{"location":"reference/commands/web/","text":"","title":"web"},{"location":"reference/commands/web/main/","text":"","title":"main"},{"location":"reference/constants/","text":"Constants for xtls_crud","title":"constants"},{"location":"reference/constants/#xtls_crud.constants--constants-for-xtls_crud","text":"","title":"Constants for xtls_crud"},{"location":"reference/constants/byte_size/","text":"ByteSize Constants, Types and Enums for xtls_crud This module contains constants, types and enums for byte sizes. Like: 1GB = 1 Gigabyte | 1TB = 1 Terabyte | 1PB = 1 Petabyte | 1EB = 1 Exabyte Size Bases: BaseModel Size Model Source code in xtls_crud/constants/byte_size.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class Size ( BaseModel ): \"\"\" Size Model \"\"\" name : str symbol : str bytes : int @root_validator () def upper_case_name ( cls , values ): values [ 'name' ] = values [ 'name' ] . upper () return values @root_validator () def upper_case_symbol ( cls , values ): values [ 'symbol' ] = values [ 'symbol' ] . upper () return values @root_validator () def positive_bytes ( cls , values ): if values [ 'bytes' ] < 0 : raise ValueError ( 'bytes must be positive' ) return values def __str__ ( self ): return f \"Time(' { self . name } ', ' { self . symbol } ', { self . bytes } )\" def __repr__ ( self ): return f \"Time(' { self . name } ', ' { self . symbol } ', { self . bytes } )\" def __eq__ ( self , other ): if isinstance ( other , Size ): return self . bytes == other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes == other if isinstance ( other , str ): return self . symbol == other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __ne__ ( self , other ): return not self . __eq__ ( other ) def __lt__ ( self , other ): if isinstance ( other , Size ): return self . bytes < other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes < other if isinstance ( other , str ): raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __le__ ( self , other ): if isinstance ( other , Size ): return self . bytes <= other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes <= other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __gt__ ( self , other ): if isinstance ( other , Size ): return self . bytes > other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes > other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __ge__ ( self , other ): if isinstance ( other , Size ): return self . bytes >= other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes >= other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __add__ ( self , other ): if isinstance ( other , Size ): return self . bytes + other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes + other raise TypeError ( f 'Cannot add { type ( self ) } with { type ( other ) } ' ) def __sub__ ( self , other ): if isinstance ( other , Size ): return self . bytes - other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes - other raise TypeError ( f 'Cannot subtract { type ( self ) } with { type ( other ) } ' ) def __mul__ ( self , other ): if isinstance ( other , Size ): return self . bytes * other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes * other raise TypeError ( f 'Cannot multiply { type ( self ) } with { type ( other ) } ' ) def __truediv__ ( self , other ): if isinstance ( other , Size ): return self . bytes / other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes / other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' ) def __floordiv__ ( self , other ): if isinstance ( other , Size ): return self . bytes // other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes // other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' ) def __mod__ ( self , other ): if isinstance ( other , Size ): return self . bytes % other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes % other raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __divmod__ ( self , other ): if isinstance ( other , Size ): return divmod ( self . bytes , other . bytes ) if isinstance ( other , int ) or isinstance ( other , float ): return divmod ( self . bytes , other ) raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __pow__ ( self , other ): if isinstance ( other , Size ): return self . bytes ** other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes ** other raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __radd__ ( self , other ): return self . __add__ ( other ) def __rsub__ ( self , other ): return self . __sub__ ( other ) def __rmul__ ( self , other ): return self . __mul__ ( other ) def __rtruediv__ ( self , other ): return self . __truediv__ ( other ) def __rfloordiv__ ( self , other ): return self . __floordiv__ ( other ) def __rmod__ ( self , other ): return self . __mod__ ( other ) def __rdivmod__ ( self , other ): return self . __divmod__ ( other ) def __rpow__ ( self , other ): return self . __pow__ ( other ) def __iadd__ ( self , other ): if isinstance ( other , Size ): self . bytes += other . bytes if isinstance ( other , int ) or isinstance ( other , float ): self . bytes += other raise TypeError ( f 'Cannot add { type ( self ) } with { type ( other ) } ' ) def __isub__ ( self , other ): if isinstance ( other , Size ): self . bytes -= other . bytes if isinstance ( other , int ) or isinstance ( other , float ): self . bytes -= other raise TypeError ( f 'Cannot subtract { type ( self ) } with { type ( other ) } ' ) def __imul__ ( self , other ): if isinstance ( other , Size ): self . bytes *= other . bytes if isinstance ( other , int ) or isinstance ( other , float ): self . bytes *= other raise TypeError ( f 'Cannot multiply { type ( self ) } with { type ( other ) } ' ) def __itruediv__ ( self , other ): if isinstance ( other , Size ): self . bytes /= other . bytes if isinstance ( other , int ) or isinstance ( other , float ): self . bytes /= other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' ) SizeUnit Bases: Enum Enum for size units Source code in xtls_crud/constants/byte_size.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 class SizeUnit ( Enum ): \"\"\" Enum for size units \"\"\" BYTE = BYTE KILOBYTE = KILOBYTE MEGABYTE = MEGABYTE GIGABYTE = GIGABYTE TERABYTE = TERABYTE PETABYTE = PETABYTE EXABYTE = EXABYTE @property def name ( self ) -> str : \"\"\" Get the name of the unit Returns: str: The name of the unit \"\"\" return self . value . name @property def symbol ( self ) -> str : \"\"\" Get the symbol of the unit Returns: str: The symbol of the unit \"\"\" return self . value . symbol @property def bytes ( self ) -> int : \"\"\" Get the number of bytes in the unit Returns: int: The number of bytes in the unit \"\"\" return self . value . bytes @classmethod def all_names ( cls ) -> list [ str ]: \"\"\" Get all the names of the units Returns: list[str]: All the names of the units \"\"\" return [ unit . name for unit in cls ] @classmethod def all_symbols ( cls ) -> list [ str ]: \"\"\" Get all the symbols of the units Returns: list[str]: All the symbols of the units \"\"\" return [ unit . symbol for unit in cls ] @classmethod def all_bytes ( cls ) -> list [ int ]: \"\"\" Get all the number of bytes in the units Returns: list[int]: All the number of bytes in the units \"\"\" return [ unit . bytes for unit in cls ] @classmethod def map_symbols_by_name ( cls ) -> dict [ str , str ]: \"\"\" Map the symbols of the units by their names Returns: dict[str, str]: The symbols of the units mapped by their names \"\"\" return { name : symbol for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} @classmethod def map_names_by_symbol ( cls ) -> dict [ str , str ]: \"\"\" Map the names of the units by their symbols Returns: dict[str, str]: The names of the units mapped by their symbols \"\"\" return { symbol : name for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} @classmethod def map_bytes_by_name ( cls ) -> dict [ str , int ]: \"\"\" Map the number of bytes in the units by their names Returns: dict[str, int]: The number of bytes in the units mapped by their names \"\"\" return { name : bytes for name , bytes in zip ( cls . all_names (), cls . all_bytes ())} # noqa @classmethod def map_bytes_by_symbol ( cls ) -> dict [ str , int ]: \"\"\" Map the number of bytes in the units by their symbols Returns: dict[str, int]: The number of bytes in the units mapped by their symbols \"\"\" return { symbol : bytes for symbol , bytes in zip ( cls . all_symbols (), cls . all_bytes ())} # noqa all_bytes () classmethod Get all the number of bytes in the units Returns: Type Description list [ int ] list[int]: All the number of bytes in the units Source code in xtls_crud/constants/byte_size.py 290 291 292 293 294 295 296 297 298 299 @classmethod def all_bytes ( cls ) -> list [ int ]: \"\"\" Get all the number of bytes in the units Returns: list[int]: All the number of bytes in the units \"\"\" return [ unit . bytes for unit in cls ] all_names () classmethod Get all the names of the units Returns: Type Description list [ str ] list[str]: All the names of the units Source code in xtls_crud/constants/byte_size.py 268 269 270 271 272 273 274 275 276 277 @classmethod def all_names ( cls ) -> list [ str ]: \"\"\" Get all the names of the units Returns: list[str]: All the names of the units \"\"\" return [ unit . name for unit in cls ] all_symbols () classmethod Get all the symbols of the units Returns: Type Description list [ str ] list[str]: All the symbols of the units Source code in xtls_crud/constants/byte_size.py 279 280 281 282 283 284 285 286 287 288 @classmethod def all_symbols ( cls ) -> list [ str ]: \"\"\" Get all the symbols of the units Returns: list[str]: All the symbols of the units \"\"\" return [ unit . symbol for unit in cls ] bytes () property Get the number of bytes in the unit Returns: Name Type Description int int The number of bytes in the unit Source code in xtls_crud/constants/byte_size.py 257 258 259 260 261 262 263 264 265 266 @property def bytes ( self ) -> int : \"\"\" Get the number of bytes in the unit Returns: int: The number of bytes in the unit \"\"\" return self . value . bytes map_bytes_by_name () classmethod Map the number of bytes in the units by their names Returns: Type Description dict [ str , int ] dict[str, int]: The number of bytes in the units mapped by their names Source code in xtls_crud/constants/byte_size.py 323 324 325 326 327 328 329 330 331 332 @classmethod def map_bytes_by_name ( cls ) -> dict [ str , int ]: \"\"\" Map the number of bytes in the units by their names Returns: dict[str, int]: The number of bytes in the units mapped by their names \"\"\" return { name : bytes for name , bytes in zip ( cls . all_names (), cls . all_bytes ())} # noqa map_bytes_by_symbol () classmethod Map the number of bytes in the units by their symbols Returns: Type Description dict [ str , int ] dict[str, int]: The number of bytes in the units mapped by their symbols Source code in xtls_crud/constants/byte_size.py 334 335 336 337 338 339 340 341 342 343 @classmethod def map_bytes_by_symbol ( cls ) -> dict [ str , int ]: \"\"\" Map the number of bytes in the units by their symbols Returns: dict[str, int]: The number of bytes in the units mapped by their symbols \"\"\" return { symbol : bytes for symbol , bytes in zip ( cls . all_symbols (), cls . all_bytes ())} # noqa map_names_by_symbol () classmethod Map the names of the units by their symbols Returns: Type Description dict [ str , str ] dict[str, str]: The names of the units mapped by their symbols Source code in xtls_crud/constants/byte_size.py 312 313 314 315 316 317 318 319 320 321 @classmethod def map_names_by_symbol ( cls ) -> dict [ str , str ]: \"\"\" Map the names of the units by their symbols Returns: dict[str, str]: The names of the units mapped by their symbols \"\"\" return { symbol : name for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} map_symbols_by_name () classmethod Map the symbols of the units by their names Returns: Type Description dict [ str , str ] dict[str, str]: The symbols of the units mapped by their names Source code in xtls_crud/constants/byte_size.py 301 302 303 304 305 306 307 308 309 310 @classmethod def map_symbols_by_name ( cls ) -> dict [ str , str ]: \"\"\" Map the symbols of the units by their names Returns: dict[str, str]: The symbols of the units mapped by their names \"\"\" return { name : symbol for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} name () property Get the name of the unit Returns: Name Type Description str str The name of the unit Source code in xtls_crud/constants/byte_size.py 235 236 237 238 239 240 241 242 243 244 @property def name ( self ) -> str : \"\"\" Get the name of the unit Returns: str: The name of the unit \"\"\" return self . value . name symbol () property Get the symbol of the unit Returns: Name Type Description str str The symbol of the unit Source code in xtls_crud/constants/byte_size.py 246 247 248 249 250 251 252 253 254 255 @property def symbol ( self ) -> str : \"\"\" Get the symbol of the unit Returns: str: The symbol of the unit \"\"\" return self . value . symbol from_string ( string ) Create a size from a string Parameters: Name Type Description Default string str The string to create the size from required Returns: Name Type Description Size Size The size (e.g. 100 MB) Raises: Type Description ValueError If the string is not a valid size TypeError If the string is not a string KeyError If the string is not a valid size unit Examples: >>> from_string ( '100 MB' ) MB (MEGABYTE) Source code in xtls_crud/constants/byte_size.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def from_string ( string : str ) -> Size : \"\"\" Create a size from a string Args: string (str): The string to create the size from Returns: Size: The size (e.g. 100 MB) Raises: ValueError: If the string is not a valid size TypeError: If the string is not a string KeyError: If the string is not a valid size unit Examples: >>> from_string('100 MB') MB (MEGABYTE) \"\"\" if not isinstance ( string , str ): raise TypeError ( f 'Expected str, got { type ( string ) } ' ) if not string : raise ValueError ( 'Cannot convert empty string to Size' ) string = string . upper () digits = int ( '' . join ( filter ( str . isdigit , string ))) unit = '' . join ( filter ( str . isalpha , string )) if not digits : raise ValueError ( 'Cannot convert string to Size' ) if not unit : raise ValueError ( 'Cannot convert string to Size' ) if ( unit not in SizeUnit . all_symbols ()) and ( unit not in SizeUnit . all_names ()): raise ValueError ( f 'Cannot convert string to Size: { unit =} | { SizeUnit . all_symbols () } | { SizeUnit . all_names () } ' ) symbol = SizeUnit . map_names_by_symbol ()[ unit ] bytes = SizeUnit . map_bytes_by_symbol ()[ unit ] # noqa return Size ( name = unit , symbol = symbol , bytes = bytes * digits )","title":"byte_size"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size--bytesize-constants-types-and-enums-for-xtls_crud","text":"This module contains constants, types and enums for byte sizes. Like: 1GB = 1 Gigabyte | 1TB = 1 Terabyte | 1PB = 1 Petabyte | 1EB = 1 Exabyte","title":"ByteSize Constants, Types and Enums for xtls_crud"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.Size","text":"Bases: BaseModel Size Model Source code in xtls_crud/constants/byte_size.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class Size ( BaseModel ): \"\"\" Size Model \"\"\" name : str symbol : str bytes : int @root_validator () def upper_case_name ( cls , values ): values [ 'name' ] = values [ 'name' ] . upper () return values @root_validator () def upper_case_symbol ( cls , values ): values [ 'symbol' ] = values [ 'symbol' ] . upper () return values @root_validator () def positive_bytes ( cls , values ): if values [ 'bytes' ] < 0 : raise ValueError ( 'bytes must be positive' ) return values def __str__ ( self ): return f \"Time(' { self . name } ', ' { self . symbol } ', { self . bytes } )\" def __repr__ ( self ): return f \"Time(' { self . name } ', ' { self . symbol } ', { self . bytes } )\" def __eq__ ( self , other ): if isinstance ( other , Size ): return self . bytes == other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes == other if isinstance ( other , str ): return self . symbol == other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __ne__ ( self , other ): return not self . __eq__ ( other ) def __lt__ ( self , other ): if isinstance ( other , Size ): return self . bytes < other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes < other if isinstance ( other , str ): raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __le__ ( self , other ): if isinstance ( other , Size ): return self . bytes <= other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes <= other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __gt__ ( self , other ): if isinstance ( other , Size ): return self . bytes > other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes > other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __ge__ ( self , other ): if isinstance ( other , Size ): return self . bytes >= other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes >= other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __add__ ( self , other ): if isinstance ( other , Size ): return self . bytes + other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes + other raise TypeError ( f 'Cannot add { type ( self ) } with { type ( other ) } ' ) def __sub__ ( self , other ): if isinstance ( other , Size ): return self . bytes - other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes - other raise TypeError ( f 'Cannot subtract { type ( self ) } with { type ( other ) } ' ) def __mul__ ( self , other ): if isinstance ( other , Size ): return self . bytes * other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes * other raise TypeError ( f 'Cannot multiply { type ( self ) } with { type ( other ) } ' ) def __truediv__ ( self , other ): if isinstance ( other , Size ): return self . bytes / other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes / other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' ) def __floordiv__ ( self , other ): if isinstance ( other , Size ): return self . bytes // other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes // other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' ) def __mod__ ( self , other ): if isinstance ( other , Size ): return self . bytes % other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes % other raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __divmod__ ( self , other ): if isinstance ( other , Size ): return divmod ( self . bytes , other . bytes ) if isinstance ( other , int ) or isinstance ( other , float ): return divmod ( self . bytes , other ) raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __pow__ ( self , other ): if isinstance ( other , Size ): return self . bytes ** other . bytes if isinstance ( other , int ) or isinstance ( other , float ): return self . bytes ** other raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __radd__ ( self , other ): return self . __add__ ( other ) def __rsub__ ( self , other ): return self . __sub__ ( other ) def __rmul__ ( self , other ): return self . __mul__ ( other ) def __rtruediv__ ( self , other ): return self . __truediv__ ( other ) def __rfloordiv__ ( self , other ): return self . __floordiv__ ( other ) def __rmod__ ( self , other ): return self . __mod__ ( other ) def __rdivmod__ ( self , other ): return self . __divmod__ ( other ) def __rpow__ ( self , other ): return self . __pow__ ( other ) def __iadd__ ( self , other ): if isinstance ( other , Size ): self . bytes += other . bytes if isinstance ( other , int ) or isinstance ( other , float ): self . bytes += other raise TypeError ( f 'Cannot add { type ( self ) } with { type ( other ) } ' ) def __isub__ ( self , other ): if isinstance ( other , Size ): self . bytes -= other . bytes if isinstance ( other , int ) or isinstance ( other , float ): self . bytes -= other raise TypeError ( f 'Cannot subtract { type ( self ) } with { type ( other ) } ' ) def __imul__ ( self , other ): if isinstance ( other , Size ): self . bytes *= other . bytes if isinstance ( other , int ) or isinstance ( other , float ): self . bytes *= other raise TypeError ( f 'Cannot multiply { type ( self ) } with { type ( other ) } ' ) def __itruediv__ ( self , other ): if isinstance ( other , Size ): self . bytes /= other . bytes if isinstance ( other , int ) or isinstance ( other , float ): self . bytes /= other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' )","title":"Size"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit","text":"Bases: Enum Enum for size units Source code in xtls_crud/constants/byte_size.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 class SizeUnit ( Enum ): \"\"\" Enum for size units \"\"\" BYTE = BYTE KILOBYTE = KILOBYTE MEGABYTE = MEGABYTE GIGABYTE = GIGABYTE TERABYTE = TERABYTE PETABYTE = PETABYTE EXABYTE = EXABYTE @property def name ( self ) -> str : \"\"\" Get the name of the unit Returns: str: The name of the unit \"\"\" return self . value . name @property def symbol ( self ) -> str : \"\"\" Get the symbol of the unit Returns: str: The symbol of the unit \"\"\" return self . value . symbol @property def bytes ( self ) -> int : \"\"\" Get the number of bytes in the unit Returns: int: The number of bytes in the unit \"\"\" return self . value . bytes @classmethod def all_names ( cls ) -> list [ str ]: \"\"\" Get all the names of the units Returns: list[str]: All the names of the units \"\"\" return [ unit . name for unit in cls ] @classmethod def all_symbols ( cls ) -> list [ str ]: \"\"\" Get all the symbols of the units Returns: list[str]: All the symbols of the units \"\"\" return [ unit . symbol for unit in cls ] @classmethod def all_bytes ( cls ) -> list [ int ]: \"\"\" Get all the number of bytes in the units Returns: list[int]: All the number of bytes in the units \"\"\" return [ unit . bytes for unit in cls ] @classmethod def map_symbols_by_name ( cls ) -> dict [ str , str ]: \"\"\" Map the symbols of the units by their names Returns: dict[str, str]: The symbols of the units mapped by their names \"\"\" return { name : symbol for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} @classmethod def map_names_by_symbol ( cls ) -> dict [ str , str ]: \"\"\" Map the names of the units by their symbols Returns: dict[str, str]: The names of the units mapped by their symbols \"\"\" return { symbol : name for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} @classmethod def map_bytes_by_name ( cls ) -> dict [ str , int ]: \"\"\" Map the number of bytes in the units by their names Returns: dict[str, int]: The number of bytes in the units mapped by their names \"\"\" return { name : bytes for name , bytes in zip ( cls . all_names (), cls . all_bytes ())} # noqa @classmethod def map_bytes_by_symbol ( cls ) -> dict [ str , int ]: \"\"\" Map the number of bytes in the units by their symbols Returns: dict[str, int]: The number of bytes in the units mapped by their symbols \"\"\" return { symbol : bytes for symbol , bytes in zip ( cls . all_symbols (), cls . all_bytes ())} # noqa","title":"SizeUnit"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit.all_bytes","text":"Get all the number of bytes in the units Returns: Type Description list [ int ] list[int]: All the number of bytes in the units Source code in xtls_crud/constants/byte_size.py 290 291 292 293 294 295 296 297 298 299 @classmethod def all_bytes ( cls ) -> list [ int ]: \"\"\" Get all the number of bytes in the units Returns: list[int]: All the number of bytes in the units \"\"\" return [ unit . bytes for unit in cls ]","title":"all_bytes()"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit.all_names","text":"Get all the names of the units Returns: Type Description list [ str ] list[str]: All the names of the units Source code in xtls_crud/constants/byte_size.py 268 269 270 271 272 273 274 275 276 277 @classmethod def all_names ( cls ) -> list [ str ]: \"\"\" Get all the names of the units Returns: list[str]: All the names of the units \"\"\" return [ unit . name for unit in cls ]","title":"all_names()"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit.all_symbols","text":"Get all the symbols of the units Returns: Type Description list [ str ] list[str]: All the symbols of the units Source code in xtls_crud/constants/byte_size.py 279 280 281 282 283 284 285 286 287 288 @classmethod def all_symbols ( cls ) -> list [ str ]: \"\"\" Get all the symbols of the units Returns: list[str]: All the symbols of the units \"\"\" return [ unit . symbol for unit in cls ]","title":"all_symbols()"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit.bytes","text":"Get the number of bytes in the unit Returns: Name Type Description int int The number of bytes in the unit Source code in xtls_crud/constants/byte_size.py 257 258 259 260 261 262 263 264 265 266 @property def bytes ( self ) -> int : \"\"\" Get the number of bytes in the unit Returns: int: The number of bytes in the unit \"\"\" return self . value . bytes","title":"bytes()"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit.map_bytes_by_name","text":"Map the number of bytes in the units by their names Returns: Type Description dict [ str , int ] dict[str, int]: The number of bytes in the units mapped by their names Source code in xtls_crud/constants/byte_size.py 323 324 325 326 327 328 329 330 331 332 @classmethod def map_bytes_by_name ( cls ) -> dict [ str , int ]: \"\"\" Map the number of bytes in the units by their names Returns: dict[str, int]: The number of bytes in the units mapped by their names \"\"\" return { name : bytes for name , bytes in zip ( cls . all_names (), cls . all_bytes ())} # noqa","title":"map_bytes_by_name()"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit.map_bytes_by_symbol","text":"Map the number of bytes in the units by their symbols Returns: Type Description dict [ str , int ] dict[str, int]: The number of bytes in the units mapped by their symbols Source code in xtls_crud/constants/byte_size.py 334 335 336 337 338 339 340 341 342 343 @classmethod def map_bytes_by_symbol ( cls ) -> dict [ str , int ]: \"\"\" Map the number of bytes in the units by their symbols Returns: dict[str, int]: The number of bytes in the units mapped by their symbols \"\"\" return { symbol : bytes for symbol , bytes in zip ( cls . all_symbols (), cls . all_bytes ())} # noqa","title":"map_bytes_by_symbol()"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit.map_names_by_symbol","text":"Map the names of the units by their symbols Returns: Type Description dict [ str , str ] dict[str, str]: The names of the units mapped by their symbols Source code in xtls_crud/constants/byte_size.py 312 313 314 315 316 317 318 319 320 321 @classmethod def map_names_by_symbol ( cls ) -> dict [ str , str ]: \"\"\" Map the names of the units by their symbols Returns: dict[str, str]: The names of the units mapped by their symbols \"\"\" return { symbol : name for name , symbol in zip ( cls . all_names (), cls . all_symbols ())}","title":"map_names_by_symbol()"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit.map_symbols_by_name","text":"Map the symbols of the units by their names Returns: Type Description dict [ str , str ] dict[str, str]: The symbols of the units mapped by their names Source code in xtls_crud/constants/byte_size.py 301 302 303 304 305 306 307 308 309 310 @classmethod def map_symbols_by_name ( cls ) -> dict [ str , str ]: \"\"\" Map the symbols of the units by their names Returns: dict[str, str]: The symbols of the units mapped by their names \"\"\" return { name : symbol for name , symbol in zip ( cls . all_names (), cls . all_symbols ())}","title":"map_symbols_by_name()"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit.name","text":"Get the name of the unit Returns: Name Type Description str str The name of the unit Source code in xtls_crud/constants/byte_size.py 235 236 237 238 239 240 241 242 243 244 @property def name ( self ) -> str : \"\"\" Get the name of the unit Returns: str: The name of the unit \"\"\" return self . value . name","title":"name()"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.SizeUnit.symbol","text":"Get the symbol of the unit Returns: Name Type Description str str The symbol of the unit Source code in xtls_crud/constants/byte_size.py 246 247 248 249 250 251 252 253 254 255 @property def symbol ( self ) -> str : \"\"\" Get the symbol of the unit Returns: str: The symbol of the unit \"\"\" return self . value . symbol","title":"symbol()"},{"location":"reference/constants/byte_size/#xtls_crud.constants.byte_size.from_string","text":"Create a size from a string Parameters: Name Type Description Default string str The string to create the size from required Returns: Name Type Description Size Size The size (e.g. 100 MB) Raises: Type Description ValueError If the string is not a valid size TypeError If the string is not a string KeyError If the string is not a valid size unit Examples: >>> from_string ( '100 MB' ) MB (MEGABYTE) Source code in xtls_crud/constants/byte_size.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def from_string ( string : str ) -> Size : \"\"\" Create a size from a string Args: string (str): The string to create the size from Returns: Size: The size (e.g. 100 MB) Raises: ValueError: If the string is not a valid size TypeError: If the string is not a string KeyError: If the string is not a valid size unit Examples: >>> from_string('100 MB') MB (MEGABYTE) \"\"\" if not isinstance ( string , str ): raise TypeError ( f 'Expected str, got { type ( string ) } ' ) if not string : raise ValueError ( 'Cannot convert empty string to Size' ) string = string . upper () digits = int ( '' . join ( filter ( str . isdigit , string ))) unit = '' . join ( filter ( str . isalpha , string )) if not digits : raise ValueError ( 'Cannot convert string to Size' ) if not unit : raise ValueError ( 'Cannot convert string to Size' ) if ( unit not in SizeUnit . all_symbols ()) and ( unit not in SizeUnit . all_names ()): raise ValueError ( f 'Cannot convert string to Size: { unit =} | { SizeUnit . all_symbols () } | { SizeUnit . all_names () } ' ) symbol = SizeUnit . map_names_by_symbol ()[ unit ] bytes = SizeUnit . map_bytes_by_symbol ()[ unit ] # noqa return Size ( name = unit , symbol = symbol , bytes = bytes * digits )","title":"from_string()"},{"location":"reference/constants/time_info/","text":"Time Constants, Types and Enums for xtls_crud This module contains constants, types and enums for byte sizes. Like: 1d = 1 day | 1w = 1 week | 1mo = 1 month | 1y = 1 year Time Bases: BaseModel Time Model Source code in xtls_crud/constants/time_info.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 class Time ( BaseModel ): \"\"\" Time Model \"\"\" name : str symbol : str seconds : int @root_validator () def upper_case_name ( cls , values ): values [ 'name' ] = values [ 'name' ] . upper () return values @root_validator () def upper_case_symbol ( cls , values ): values [ 'symbol' ] = values [ 'symbol' ] . upper () return values @root_validator () def positive_seconds ( cls , values ): if values [ 'seconds' ] < 0 : raise ValueError ( 'seconds must be positive' ) return values def __str__ ( self ): return f \"Time(' { self . name } ', ' { self . symbol } ', { self . seconds } )\" def __repr__ ( self ): return f \"Time(' { self . name } ', ' { self . symbol } ', { self . seconds } )\" def __eq__ ( self , other ): if isinstance ( other , Time ): return self . seconds == other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds == other if isinstance ( other , str ): return self . symbol == other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __ne__ ( self , other ): return not self . __eq__ ( other ) def __lt__ ( self , other ): if isinstance ( other , Time ): return self . seconds < other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds < other if isinstance ( other , str ): raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __le__ ( self , other ): if isinstance ( other , Time ): return self . seconds <= other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds <= other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __gt__ ( self , other ): if isinstance ( other , Time ): return self . seconds > other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds > other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __ge__ ( self , other ): if isinstance ( other , Time ): return self . seconds >= other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds >= other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __add__ ( self , other ): if isinstance ( other , Time ): return self . seconds + other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds + other raise TypeError ( f 'Cannot add { type ( self ) } with { type ( other ) } ' ) def __sub__ ( self , other ): if isinstance ( other , Time ): return self . seconds - other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds - other raise TypeError ( f 'Cannot subtract { type ( self ) } with { type ( other ) } ' ) def __mul__ ( self , other ): if isinstance ( other , Time ): return self . seconds * other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds * other raise TypeError ( f 'Cannot multiply { type ( self ) } with { type ( other ) } ' ) def __truediv__ ( self , other ): if isinstance ( other , Time ): return self . seconds / other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds / other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' ) def __floordiv__ ( self , other ): if isinstance ( other , Time ): return self . seconds // other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds // other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' ) def __mod__ ( self , other ): if isinstance ( other , Time ): return self . seconds % other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds % other raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __divmod__ ( self , other ): if isinstance ( other , Time ): return divmod ( self . seconds , other . seconds ) if isinstance ( other , int ) or isinstance ( other , float ): return divmod ( self . seconds , other ) raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __pow__ ( self , other ): if isinstance ( other , Time ): return self . seconds ** other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds ** other raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __radd__ ( self , other ): return self . __add__ ( other ) def __rsub__ ( self , other ): return self . __sub__ ( other ) def __rmul__ ( self , other ): return self . __mul__ ( other ) def __rtruediv__ ( self , other ): return self . __truediv__ ( other ) def __rfloordiv__ ( self , other ): return self . __floordiv__ ( other ) def __rmod__ ( self , other ): return self . __mod__ ( other ) def __rdivmod__ ( self , other ): return self . __divmod__ ( other ) def __rpow__ ( self , other ): return self . __pow__ ( other ) def __iadd__ ( self , other ): if isinstance ( other , Time ): self . seconds += other . seconds if isinstance ( other , int ) or isinstance ( other , float ): self . seconds += other raise TypeError ( f 'Cannot add { type ( self ) } with { type ( other ) } ' ) def __isub__ ( self , other ): if isinstance ( other , Time ): self . seconds -= other . seconds if isinstance ( other , int ) or isinstance ( other , float ): self . seconds -= other raise TypeError ( f 'Cannot subtract { type ( self ) } with { type ( other ) } ' ) def __imul__ ( self , other ): if isinstance ( other , Time ): self . seconds *= other . seconds if isinstance ( other , int ) or isinstance ( other , float ): self . seconds *= other raise TypeError ( f 'Cannot multiply { type ( self ) } with { type ( other ) } ' ) def __itruediv__ ( self , other ): if isinstance ( other , Time ): self . seconds /= other . seconds if isinstance ( other , int ) or isinstance ( other , float ): self . seconds /= other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' ) TimeUnit Bases: Enum Enum for time units Source code in xtls_crud/constants/time_info.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 class TimeUnit ( Enum ): \"\"\" Enum for time units \"\"\" SECOND = SECOND MINUTE = MINUTE HOUR = HOUR DAY = DAY WEEK = WEEK MONTH = MONTH YEAR = YEAR @property def name ( self ) -> str : \"\"\" Get the name of the time unit Returns: str: The name of the time unit \"\"\" return self . value . name @property def symbol ( self ) -> str : \"\"\" Get the symbol of the time unit Returns: str: The symbol of the time unit \"\"\" return self . value . symbol @property def seconds ( self ) -> int : \"\"\" Get the number of seconds in the time unit Returns: int: The number of seconds in the time unit \"\"\" return self . value . seconds @classmethod def all_names ( cls ) -> list [ str ]: \"\"\" Get all the names of the time units Returns: list[str]: All the names of the time units \"\"\" return [ unit . name for unit in cls ] @classmethod def all_symbols ( cls ) -> list [ str ]: \"\"\" Get all the symbols of the time units Returns: list[str]: All the symbols of the time units \"\"\" return [ unit . symbol for unit in cls ] @classmethod def all_seconds ( cls ) -> list [ int ]: \"\"\" Get all the number of seconds in the time units Returns: list[int]: All the number of seconds in the time units \"\"\" return [ unit . seconds for unit in cls ] @classmethod def map_symbols_by_name ( cls ) -> dict [ str , str ]: \"\"\" Map the symbols of the time units by their names Returns: dict[str, str]: A dictionary mapping the symbols of the time units by their names \"\"\" return { name : symbol for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} @classmethod def map_names_by_symbol ( cls ) -> dict [ str , str ]: \"\"\" Map the names of the time units by their symbols Returns: dict[str, str]: A dictionary mapping the names of the time units by their symbols \"\"\" return { symbol : name for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} @classmethod def map_seconds_by_name ( cls ) -> dict [ str , int ]: \"\"\" Map the number of seconds in the time units by their names Returns: dict[str, int]: A dictionary mapping the number of seconds in the time units by their names \"\"\" return { name : seconds for name , seconds in zip ( cls . all_names (), cls . all_seconds ())} @classmethod def map_seconds_by_symbol ( cls ) -> dict [ str , int ]: \"\"\" Map the number of seconds in the time units by their symbols Returns: dict[str, int]: A dictionary mapping the number of seconds in the time units by their symbols \"\"\" return { symbol : seconds for symbol , seconds in zip ( cls . all_symbols (), cls . all_seconds ())} all_names () classmethod Get all the names of the time units Returns: Type Description list [ str ] list[str]: All the names of the time units Source code in xtls_crud/constants/time_info.py 269 270 271 272 273 274 275 276 277 278 @classmethod def all_names ( cls ) -> list [ str ]: \"\"\" Get all the names of the time units Returns: list[str]: All the names of the time units \"\"\" return [ unit . name for unit in cls ] all_seconds () classmethod Get all the number of seconds in the time units Returns: Type Description list [ int ] list[int]: All the number of seconds in the time units Source code in xtls_crud/constants/time_info.py 291 292 293 294 295 296 297 298 299 300 @classmethod def all_seconds ( cls ) -> list [ int ]: \"\"\" Get all the number of seconds in the time units Returns: list[int]: All the number of seconds in the time units \"\"\" return [ unit . seconds for unit in cls ] all_symbols () classmethod Get all the symbols of the time units Returns: Type Description list [ str ] list[str]: All the symbols of the time units Source code in xtls_crud/constants/time_info.py 280 281 282 283 284 285 286 287 288 289 @classmethod def all_symbols ( cls ) -> list [ str ]: \"\"\" Get all the symbols of the time units Returns: list[str]: All the symbols of the time units \"\"\" return [ unit . symbol for unit in cls ] map_names_by_symbol () classmethod Map the names of the time units by their symbols Returns: Type Description dict [ str , str ] dict[str, str]: A dictionary mapping the names of the time units by their symbols Source code in xtls_crud/constants/time_info.py 313 314 315 316 317 318 319 320 321 322 @classmethod def map_names_by_symbol ( cls ) -> dict [ str , str ]: \"\"\" Map the names of the time units by their symbols Returns: dict[str, str]: A dictionary mapping the names of the time units by their symbols \"\"\" return { symbol : name for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} map_seconds_by_name () classmethod Map the number of seconds in the time units by their names Returns: Type Description dict [ str , int ] dict[str, int]: A dictionary mapping the number of seconds in the time units by their names Source code in xtls_crud/constants/time_info.py 324 325 326 327 328 329 330 331 332 333 @classmethod def map_seconds_by_name ( cls ) -> dict [ str , int ]: \"\"\" Map the number of seconds in the time units by their names Returns: dict[str, int]: A dictionary mapping the number of seconds in the time units by their names \"\"\" return { name : seconds for name , seconds in zip ( cls . all_names (), cls . all_seconds ())} map_seconds_by_symbol () classmethod Map the number of seconds in the time units by their symbols Returns: Type Description dict [ str , int ] dict[str, int]: A dictionary mapping the number of seconds in the time units by their symbols Source code in xtls_crud/constants/time_info.py 335 336 337 338 339 340 341 342 343 344 @classmethod def map_seconds_by_symbol ( cls ) -> dict [ str , int ]: \"\"\" Map the number of seconds in the time units by their symbols Returns: dict[str, int]: A dictionary mapping the number of seconds in the time units by their symbols \"\"\" return { symbol : seconds for symbol , seconds in zip ( cls . all_symbols (), cls . all_seconds ())} map_symbols_by_name () classmethod Map the symbols of the time units by their names Returns: Type Description dict [ str , str ] dict[str, str]: A dictionary mapping the symbols of the time units by their names Source code in xtls_crud/constants/time_info.py 302 303 304 305 306 307 308 309 310 311 @classmethod def map_symbols_by_name ( cls ) -> dict [ str , str ]: \"\"\" Map the symbols of the time units by their names Returns: dict[str, str]: A dictionary mapping the symbols of the time units by their names \"\"\" return { name : symbol for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} name () property Get the name of the time unit Returns: Name Type Description str str The name of the time unit Source code in xtls_crud/constants/time_info.py 236 237 238 239 240 241 242 243 244 245 @property def name ( self ) -> str : \"\"\" Get the name of the time unit Returns: str: The name of the time unit \"\"\" return self . value . name seconds () property Get the number of seconds in the time unit Returns: Name Type Description int int The number of seconds in the time unit Source code in xtls_crud/constants/time_info.py 258 259 260 261 262 263 264 265 266 267 @property def seconds ( self ) -> int : \"\"\" Get the number of seconds in the time unit Returns: int: The number of seconds in the time unit \"\"\" return self . value . seconds symbol () property Get the symbol of the time unit Returns: Name Type Description str str The symbol of the time unit Source code in xtls_crud/constants/time_info.py 247 248 249 250 251 252 253 254 255 256 @property def symbol ( self ) -> str : \"\"\" Get the symbol of the time unit Returns: str: The symbol of the time unit \"\"\" return self . value . symbol from_string ( string ) Create a time from a string Parameters: Name Type Description Default string str The string to create the time from required Returns: Name Type Description Time Time The time Raises: Type Description ValueError If the string is not a valid time TypeError If the string is not a string KeyError If the string is not a valid time unit Examples: >>> from_string ( '1s' ) Time('S', 'SECOND', 1) Source code in xtls_crud/constants/time_info.py 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def from_string ( string : str ) -> Time : \"\"\" Create a time from a string Args: string (str): The string to create the time from Returns: Time: The time Raises: ValueError: If the string is not a valid time TypeError: If the string is not a string KeyError: If the string is not a valid time unit Examples: >>> from_string('1s') Time('S', 'SECOND', 1) \"\"\" if not isinstance ( string , str ): raise TypeError ( f 'Expected str, got { type ( string ) } ' ) if not string : raise ValueError ( 'Cannot convert empty string to Time' ) string = string . upper () digits = int ( '' . join ( filter ( str . isdigit , string ))) unit = '' . join ( filter ( str . isalpha , string )) if not digits : raise ValueError ( 'Cannot convert string to Time' ) if not unit : raise ValueError ( 'Cannot convert string to Time' ) if ( unit not in TimeUnit . all_symbols ()) and ( unit not in TimeUnit . all_names ()): raise ValueError ( f 'Cannot convert string to Time: { unit =} | { TimeUnit . all_symbols () } | { TimeUnit . all_names () } ' ) symbol = TimeUnit . map_names_by_symbol ()[ unit ] seconds = TimeUnit . map_seconds_by_symbol ()[ unit ] return Time ( name = unit , symbol = symbol , seconds = seconds * digits )","title":"time_info"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info--time-constants-types-and-enums-for-xtls_crud","text":"This module contains constants, types and enums for byte sizes. Like: 1d = 1 day | 1w = 1 week | 1mo = 1 month | 1y = 1 year","title":"Time Constants, Types and Enums for xtls_crud"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.Time","text":"Bases: BaseModel Time Model Source code in xtls_crud/constants/time_info.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 class Time ( BaseModel ): \"\"\" Time Model \"\"\" name : str symbol : str seconds : int @root_validator () def upper_case_name ( cls , values ): values [ 'name' ] = values [ 'name' ] . upper () return values @root_validator () def upper_case_symbol ( cls , values ): values [ 'symbol' ] = values [ 'symbol' ] . upper () return values @root_validator () def positive_seconds ( cls , values ): if values [ 'seconds' ] < 0 : raise ValueError ( 'seconds must be positive' ) return values def __str__ ( self ): return f \"Time(' { self . name } ', ' { self . symbol } ', { self . seconds } )\" def __repr__ ( self ): return f \"Time(' { self . name } ', ' { self . symbol } ', { self . seconds } )\" def __eq__ ( self , other ): if isinstance ( other , Time ): return self . seconds == other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds == other if isinstance ( other , str ): return self . symbol == other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __ne__ ( self , other ): return not self . __eq__ ( other ) def __lt__ ( self , other ): if isinstance ( other , Time ): return self . seconds < other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds < other if isinstance ( other , str ): raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __le__ ( self , other ): if isinstance ( other , Time ): return self . seconds <= other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds <= other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __gt__ ( self , other ): if isinstance ( other , Time ): return self . seconds > other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds > other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __ge__ ( self , other ): if isinstance ( other , Time ): return self . seconds >= other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds >= other raise TypeError ( f 'Cannot compare { type ( self ) } with { type ( other ) } ' ) def __add__ ( self , other ): if isinstance ( other , Time ): return self . seconds + other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds + other raise TypeError ( f 'Cannot add { type ( self ) } with { type ( other ) } ' ) def __sub__ ( self , other ): if isinstance ( other , Time ): return self . seconds - other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds - other raise TypeError ( f 'Cannot subtract { type ( self ) } with { type ( other ) } ' ) def __mul__ ( self , other ): if isinstance ( other , Time ): return self . seconds * other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds * other raise TypeError ( f 'Cannot multiply { type ( self ) } with { type ( other ) } ' ) def __truediv__ ( self , other ): if isinstance ( other , Time ): return self . seconds / other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds / other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' ) def __floordiv__ ( self , other ): if isinstance ( other , Time ): return self . seconds // other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds // other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' ) def __mod__ ( self , other ): if isinstance ( other , Time ): return self . seconds % other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds % other raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __divmod__ ( self , other ): if isinstance ( other , Time ): return divmod ( self . seconds , other . seconds ) if isinstance ( other , int ) or isinstance ( other , float ): return divmod ( self . seconds , other ) raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __pow__ ( self , other ): if isinstance ( other , Time ): return self . seconds ** other . seconds if isinstance ( other , int ) or isinstance ( other , float ): return self . seconds ** other raise TypeError ( f 'Cannot mod { type ( self ) } with { type ( other ) } ' ) def __radd__ ( self , other ): return self . __add__ ( other ) def __rsub__ ( self , other ): return self . __sub__ ( other ) def __rmul__ ( self , other ): return self . __mul__ ( other ) def __rtruediv__ ( self , other ): return self . __truediv__ ( other ) def __rfloordiv__ ( self , other ): return self . __floordiv__ ( other ) def __rmod__ ( self , other ): return self . __mod__ ( other ) def __rdivmod__ ( self , other ): return self . __divmod__ ( other ) def __rpow__ ( self , other ): return self . __pow__ ( other ) def __iadd__ ( self , other ): if isinstance ( other , Time ): self . seconds += other . seconds if isinstance ( other , int ) or isinstance ( other , float ): self . seconds += other raise TypeError ( f 'Cannot add { type ( self ) } with { type ( other ) } ' ) def __isub__ ( self , other ): if isinstance ( other , Time ): self . seconds -= other . seconds if isinstance ( other , int ) or isinstance ( other , float ): self . seconds -= other raise TypeError ( f 'Cannot subtract { type ( self ) } with { type ( other ) } ' ) def __imul__ ( self , other ): if isinstance ( other , Time ): self . seconds *= other . seconds if isinstance ( other , int ) or isinstance ( other , float ): self . seconds *= other raise TypeError ( f 'Cannot multiply { type ( self ) } with { type ( other ) } ' ) def __itruediv__ ( self , other ): if isinstance ( other , Time ): self . seconds /= other . seconds if isinstance ( other , int ) or isinstance ( other , float ): self . seconds /= other raise TypeError ( f 'Cannot divide { type ( self ) } with { type ( other ) } ' )","title":"Time"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit","text":"Bases: Enum Enum for time units Source code in xtls_crud/constants/time_info.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 class TimeUnit ( Enum ): \"\"\" Enum for time units \"\"\" SECOND = SECOND MINUTE = MINUTE HOUR = HOUR DAY = DAY WEEK = WEEK MONTH = MONTH YEAR = YEAR @property def name ( self ) -> str : \"\"\" Get the name of the time unit Returns: str: The name of the time unit \"\"\" return self . value . name @property def symbol ( self ) -> str : \"\"\" Get the symbol of the time unit Returns: str: The symbol of the time unit \"\"\" return self . value . symbol @property def seconds ( self ) -> int : \"\"\" Get the number of seconds in the time unit Returns: int: The number of seconds in the time unit \"\"\" return self . value . seconds @classmethod def all_names ( cls ) -> list [ str ]: \"\"\" Get all the names of the time units Returns: list[str]: All the names of the time units \"\"\" return [ unit . name for unit in cls ] @classmethod def all_symbols ( cls ) -> list [ str ]: \"\"\" Get all the symbols of the time units Returns: list[str]: All the symbols of the time units \"\"\" return [ unit . symbol for unit in cls ] @classmethod def all_seconds ( cls ) -> list [ int ]: \"\"\" Get all the number of seconds in the time units Returns: list[int]: All the number of seconds in the time units \"\"\" return [ unit . seconds for unit in cls ] @classmethod def map_symbols_by_name ( cls ) -> dict [ str , str ]: \"\"\" Map the symbols of the time units by their names Returns: dict[str, str]: A dictionary mapping the symbols of the time units by their names \"\"\" return { name : symbol for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} @classmethod def map_names_by_symbol ( cls ) -> dict [ str , str ]: \"\"\" Map the names of the time units by their symbols Returns: dict[str, str]: A dictionary mapping the names of the time units by their symbols \"\"\" return { symbol : name for name , symbol in zip ( cls . all_names (), cls . all_symbols ())} @classmethod def map_seconds_by_name ( cls ) -> dict [ str , int ]: \"\"\" Map the number of seconds in the time units by their names Returns: dict[str, int]: A dictionary mapping the number of seconds in the time units by their names \"\"\" return { name : seconds for name , seconds in zip ( cls . all_names (), cls . all_seconds ())} @classmethod def map_seconds_by_symbol ( cls ) -> dict [ str , int ]: \"\"\" Map the number of seconds in the time units by their symbols Returns: dict[str, int]: A dictionary mapping the number of seconds in the time units by their symbols \"\"\" return { symbol : seconds for symbol , seconds in zip ( cls . all_symbols (), cls . all_seconds ())}","title":"TimeUnit"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit.all_names","text":"Get all the names of the time units Returns: Type Description list [ str ] list[str]: All the names of the time units Source code in xtls_crud/constants/time_info.py 269 270 271 272 273 274 275 276 277 278 @classmethod def all_names ( cls ) -> list [ str ]: \"\"\" Get all the names of the time units Returns: list[str]: All the names of the time units \"\"\" return [ unit . name for unit in cls ]","title":"all_names()"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit.all_seconds","text":"Get all the number of seconds in the time units Returns: Type Description list [ int ] list[int]: All the number of seconds in the time units Source code in xtls_crud/constants/time_info.py 291 292 293 294 295 296 297 298 299 300 @classmethod def all_seconds ( cls ) -> list [ int ]: \"\"\" Get all the number of seconds in the time units Returns: list[int]: All the number of seconds in the time units \"\"\" return [ unit . seconds for unit in cls ]","title":"all_seconds()"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit.all_symbols","text":"Get all the symbols of the time units Returns: Type Description list [ str ] list[str]: All the symbols of the time units Source code in xtls_crud/constants/time_info.py 280 281 282 283 284 285 286 287 288 289 @classmethod def all_symbols ( cls ) -> list [ str ]: \"\"\" Get all the symbols of the time units Returns: list[str]: All the symbols of the time units \"\"\" return [ unit . symbol for unit in cls ]","title":"all_symbols()"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit.map_names_by_symbol","text":"Map the names of the time units by their symbols Returns: Type Description dict [ str , str ] dict[str, str]: A dictionary mapping the names of the time units by their symbols Source code in xtls_crud/constants/time_info.py 313 314 315 316 317 318 319 320 321 322 @classmethod def map_names_by_symbol ( cls ) -> dict [ str , str ]: \"\"\" Map the names of the time units by their symbols Returns: dict[str, str]: A dictionary mapping the names of the time units by their symbols \"\"\" return { symbol : name for name , symbol in zip ( cls . all_names (), cls . all_symbols ())}","title":"map_names_by_symbol()"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit.map_seconds_by_name","text":"Map the number of seconds in the time units by their names Returns: Type Description dict [ str , int ] dict[str, int]: A dictionary mapping the number of seconds in the time units by their names Source code in xtls_crud/constants/time_info.py 324 325 326 327 328 329 330 331 332 333 @classmethod def map_seconds_by_name ( cls ) -> dict [ str , int ]: \"\"\" Map the number of seconds in the time units by their names Returns: dict[str, int]: A dictionary mapping the number of seconds in the time units by their names \"\"\" return { name : seconds for name , seconds in zip ( cls . all_names (), cls . all_seconds ())}","title":"map_seconds_by_name()"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit.map_seconds_by_symbol","text":"Map the number of seconds in the time units by their symbols Returns: Type Description dict [ str , int ] dict[str, int]: A dictionary mapping the number of seconds in the time units by their symbols Source code in xtls_crud/constants/time_info.py 335 336 337 338 339 340 341 342 343 344 @classmethod def map_seconds_by_symbol ( cls ) -> dict [ str , int ]: \"\"\" Map the number of seconds in the time units by their symbols Returns: dict[str, int]: A dictionary mapping the number of seconds in the time units by their symbols \"\"\" return { symbol : seconds for symbol , seconds in zip ( cls . all_symbols (), cls . all_seconds ())}","title":"map_seconds_by_symbol()"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit.map_symbols_by_name","text":"Map the symbols of the time units by their names Returns: Type Description dict [ str , str ] dict[str, str]: A dictionary mapping the symbols of the time units by their names Source code in xtls_crud/constants/time_info.py 302 303 304 305 306 307 308 309 310 311 @classmethod def map_symbols_by_name ( cls ) -> dict [ str , str ]: \"\"\" Map the symbols of the time units by their names Returns: dict[str, str]: A dictionary mapping the symbols of the time units by their names \"\"\" return { name : symbol for name , symbol in zip ( cls . all_names (), cls . all_symbols ())}","title":"map_symbols_by_name()"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit.name","text":"Get the name of the time unit Returns: Name Type Description str str The name of the time unit Source code in xtls_crud/constants/time_info.py 236 237 238 239 240 241 242 243 244 245 @property def name ( self ) -> str : \"\"\" Get the name of the time unit Returns: str: The name of the time unit \"\"\" return self . value . name","title":"name()"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit.seconds","text":"Get the number of seconds in the time unit Returns: Name Type Description int int The number of seconds in the time unit Source code in xtls_crud/constants/time_info.py 258 259 260 261 262 263 264 265 266 267 @property def seconds ( self ) -> int : \"\"\" Get the number of seconds in the time unit Returns: int: The number of seconds in the time unit \"\"\" return self . value . seconds","title":"seconds()"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.TimeUnit.symbol","text":"Get the symbol of the time unit Returns: Name Type Description str str The symbol of the time unit Source code in xtls_crud/constants/time_info.py 247 248 249 250 251 252 253 254 255 256 @property def symbol ( self ) -> str : \"\"\" Get the symbol of the time unit Returns: str: The symbol of the time unit \"\"\" return self . value . symbol","title":"symbol()"},{"location":"reference/constants/time_info/#xtls_crud.constants.time_info.from_string","text":"Create a time from a string Parameters: Name Type Description Default string str The string to create the time from required Returns: Name Type Description Time Time The time Raises: Type Description ValueError If the string is not a valid time TypeError If the string is not a string KeyError If the string is not a valid time unit Examples: >>> from_string ( '1s' ) Time('S', 'SECOND', 1) Source code in xtls_crud/constants/time_info.py 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def from_string ( string : str ) -> Time : \"\"\" Create a time from a string Args: string (str): The string to create the time from Returns: Time: The time Raises: ValueError: If the string is not a valid time TypeError: If the string is not a string KeyError: If the string is not a valid time unit Examples: >>> from_string('1s') Time('S', 'SECOND', 1) \"\"\" if not isinstance ( string , str ): raise TypeError ( f 'Expected str, got { type ( string ) } ' ) if not string : raise ValueError ( 'Cannot convert empty string to Time' ) string = string . upper () digits = int ( '' . join ( filter ( str . isdigit , string ))) unit = '' . join ( filter ( str . isalpha , string )) if not digits : raise ValueError ( 'Cannot convert string to Time' ) if not unit : raise ValueError ( 'Cannot convert string to Time' ) if ( unit not in TimeUnit . all_symbols ()) and ( unit not in TimeUnit . all_names ()): raise ValueError ( f 'Cannot convert string to Time: { unit =} | { TimeUnit . all_symbols () } | { TimeUnit . all_names () } ' ) symbol = TimeUnit . map_names_by_symbol ()[ unit ] seconds = TimeUnit . map_seconds_by_symbol ()[ unit ] return Time ( name = unit , symbol = symbol , seconds = seconds * digits )","title":"from_string()"},{"location":"reference/core/","text":"","title":"core"},{"location":"reference/core/settings/","text":"","title":"settings"},{"location":"reference/database/","text":"","title":"database"},{"location":"reference/database/crud/","text":"","title":"crud"},{"location":"reference/database/crud/base/","text":"","title":"base"},{"location":"reference/database/crud/crud_inbounds/","text":"","title":"crud_inbounds"},{"location":"reference/database/db/","text":"","title":"db"},{"location":"reference/database/db/base/","text":"","title":"base"},{"location":"reference/database/db/base_class/","text":"","title":"base_class"},{"location":"reference/database/db/session/","text":"","title":"session"},{"location":"reference/database/models/","text":"","title":"models"},{"location":"reference/database/models/inbounds/","text":"","title":"inbounds"},{"location":"reference/database/schemas/","text":"","title":"schemas"},{"location":"reference/database/schemas/inbounds/","text":"","title":"inbounds"},{"location":"reference/models/","text":"","title":"models"},{"location":"reference/models/inbounds/","text":"","title":"inbounds"},{"location":"reference/models/inbounds/easy_inbounds_builder/","text":"","title":"easy_inbounds_builder"},{"location":"reference/models/inbounds/inbounds/","text":"","title":"inbounds"},{"location":"reference/models/inbounds/settings/","text":"","title":"settings"},{"location":"reference/models/inbounds/sniffing/","text":"","title":"sniffing"},{"location":"reference/models/inbounds/stream_settings/","text":"","title":"stream_settings"},{"location":"reference/utils/","text":"","title":"utils"},{"location":"reference/utils/builders/","text":"","title":"builders"},{"location":"reference/utils/builders/inbounds_builder/","text":"","title":"inbounds_builder"},{"location":"reference/web/","text":"","title":"web"}]}